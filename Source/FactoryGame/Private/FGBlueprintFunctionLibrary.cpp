// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGBlueprintFunctionLibrary.h"

AActor* UFGBlueprintFunctionLibrary::GetOuterActor(const UObject* obj){ return nullptr; }
void UFGBlueprintFunctionLibrary::ShowOutline( UPrimitiveComponent* comp, EOutlineColor color){ }
void UFGBlueprintFunctionLibrary::OccludeOutlineByComponent( UPrimitiveComponent* comp, bool occlude){ }
void UFGBlueprintFunctionLibrary::OccludeOutlineByActor( AActor* actor, bool occlude){ }
void UFGBlueprintFunctionLibrary::HideOutline( UPrimitiveComponent* comp){ }
void UFGBlueprintFunctionLibrary::UpdateUseState(FUseState& state, TSubclassOf< UFGUseState > newState){ }
void UFGBlueprintFunctionLibrary::Cheat_GetAllDescriptors(TArray< TSubclassOf<  UFGItemDescriptor > >& out_descriptors){ }
void UFGBlueprintFunctionLibrary::GetAllDescriptorsSorted(UObject* worldContext,  TArray< TSubclassOf< UFGItemDescriptor > >& out_descriptors){ }
void UFGBlueprintFunctionLibrary::ChangeLanguage(FString target){ }
FString UFGBlueprintFunctionLibrary::GetLanguage(){ return FString(); }
bool UFGBlueprintFunctionLibrary::IsEditorWorld( UObject* worldContext){ return bool(); }
bool UFGBlueprintFunctionLibrary::IsGameWorld( UObject* worldContext){ return bool(); }
float UFGBlueprintFunctionLibrary::LogX(float base, float value){ return float(); }
float UFGBlueprintFunctionLibrary::RoundFloatWithPrecision(float value, int32 MaximumFractionalDigits){ return float(); }
FName UFGBlueprintFunctionLibrary::GetComponentFlagSoftLanding(){ return FName(); }
bool UFGBlueprintFunctionLibrary::IsInAlwaysLoadedLevel(AActor* actor){ return bool(); }
UFGSignificanceManager* UFGBlueprintFunctionLibrary::GetSignificanceManager(UWorld* InWorld){ return nullptr; }
void UFGBlueprintFunctionLibrary::AddGenericTickObjectToSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::RemoveGenericTickObjectFromSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::AddFactoryObjectToSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::RemoveFactoryObjectFromSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::AddConveyorBeltToSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::RemoveConveyorBeltFromSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::AddPipelineToSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::RemoveFromSignificanceManagerGeneric(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::AddGainSignificanceObjectToSignificanceManager(UObject* WorldContextObject, UObject* obj, float desiredGainDistance){ }
void UFGBlueprintFunctionLibrary::RemoveGainSignificanceObjectFromSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::AddAudioVolumeToSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::RemoveAudioVolumeFromSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::AddAmbientSoundSplineToSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::RemoveAmbientSoundSplineFromSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::AddTrainToSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
void UFGBlueprintFunctionLibrary::RemoveTrainFromSignificanceManager(UObject* WorldContextObject, UObject* obj){ }
bool UFGBlueprintFunctionLibrary::ImpactEffectIsRelevant(UObject* worldContext, APawn* instigator, FVector spawnLocation, float visibleCullDistance , float alwaysSuccessDistance , bool skipLOSCheck){ return bool(); }
bool UFGBlueprintFunctionLibrary::ImpactEffectIsWithinDistance(UObject* worldContext, APawn* instigator, FVector spawnLocation, float visibleCullDistance){ return bool(); }
bool UFGBlueprintFunctionLibrary::IsLocallyHumanControlled(APawn* pawn){ return bool(); }
FString UFGBlueprintFunctionLibrary::GetVersionString(){ return FString(); }
bool UFGBlueprintFunctionLibrary::IsAlphaBuild(){ return bool(); }
bool UFGBlueprintFunctionLibrary::CanBeOnConveyor(TSubclassOf< UFGItemDescriptor > inClass){ return bool(); }
void UFGBlueprintFunctionLibrary::GetAllBuildCategories(UObject* worldContext,  TArray< TSubclassOf<  UFGBuildCategory > >& out_buildCategories){ }
void UFGBlueprintFunctionLibrary::GetAvailableRecipesInCategory(UObject* worldContext, TSubclassOf< UFGBuildCategory > buildCategory,  TArray< TSubclassOf<  UFGRecipe > >& out_recipes){ }
void UFGBlueprintFunctionLibrary::GetAvailableRecipesInSubCategory(UObject* worldContext, TSubclassOf< UFGBuildCategory > buildCategory, TSubclassOf< UFGBuildSubCategory > subCategory,  TArray< TSubclassOf<  UFGRecipe > >& out_recipes){ }
void UFGBlueprintFunctionLibrary::GetAvailableSubCategoriesForCategory(UObject* worldContext, TSubclassOf< UFGBuildCategory > buildCategory,  TArray< TSubclassOf<  UFGBuildSubCategory > >& out_subCategories){ }
void UFGBlueprintFunctionLibrary::GetSubCategoriesForSchematicCategory(UObject* worldContext, TSubclassOf< UFGSchematicCategory > buildCategory,  TArray< TSubclassOf<  UFGSchematicCategory > >& out_subCategories){ }
void UFGBlueprintFunctionLibrary::GetAllWidgetsOfClassInHierarchy(UWidget* hierarchyContext, TSubclassOf< UWidget > widgetClass, TArray< UWidget* >& foundWidgets){ }
TArray< TSubclassOf< class UFGItemDescriptor > > UFGBlueprintFunctionLibrary::GetAllItemsInCategory(UObject* worldContext, TSubclassOf< UFGItemCategory > itemCategory){ return TArray<TSubclassOf<class UFGItemDescriptor> >(); }
TArray< TSubclassOf< class UFGItemCategory > > UFGBlueprintFunctionLibrary::GetCategoriesWithAffordableRecipes(AFGCharacterPlayer* playerPawn, TSubclassOf< UObject > forProducer){ return TArray<TSubclassOf<class UFGItemCategory> >(); }
bool UFGBlueprintFunctionLibrary::IsLocationNearABase(const UObject* worldContext, FVector inLocation, float closeDistance){ return bool(); }
bool UFGBlueprintFunctionLibrary::IsLocationNearABaseFromResult(const UObject* worldContext, FVector inLocation, float closeDistance, const TArray< FOverlapResult >& Results){ return bool(); }
void UFGBlueprintFunctionLibrary::CreateSessionAndTravelToMap(APlayerController* player, const FString& mapName, const FString& options, const FString& sessionName, TEnumAsByte<ESessionVisibility> sessionVisibility){ }
void UFGBlueprintFunctionLibrary::TravelToMainMenu(APlayerController* playerController){ }
void UFGBlueprintFunctionLibrary::SendLocalPlayerToMainMenu(UWorld* world){ }
FString UFGBlueprintFunctionLibrary::LinearColorToHex(FLinearColor inColor){ return FString(); }
void UFGBlueprintFunctionLibrary::AddPopup(APlayerController* controller, FText Title, FText Body, const FPopupConfirmClicked& ConfirmClickDelegate, EPopupId PopupID , TSubclassOf< UUserWidget > popupClass , UObject* popupInstigator){ }
void UFGBlueprintFunctionLibrary::AddPopupWithCloseDelegate(APlayerController* controller, FText Title, FText Body, const FPopupClosed& CloseDelegate, EPopupId PopupID , TSubclassOf< UUserWidget > popupClass , UObject* popupInstigator){ }
void UFGBlueprintFunctionLibrary::ClosePopup(APlayerController* controller){ }
void UFGBlueprintFunctionLibrary::CopyTextToClipboard(FText textToCopy){ }
FText UFGBlueprintFunctionLibrary::CopyTextFromClipboard(){ return FText(); }
AFGPlayerController* UFGBlueprintFunctionLibrary::GetLocalPlayerController(const UObject* worldContext){ return nullptr; }
bool UFGBlueprintFunctionLibrary::EvaluateMathExpression(const FString& expression,  FText& out_Result){ return bool(); }
void UFGBlueprintFunctionLibrary::SetMetadataTag(UObject* object, FName tag, const FString& value){ }
FString UFGBlueprintFunctionLibrary::GetMetadataTag(UObject* object, FName tag){ return FString(); }
