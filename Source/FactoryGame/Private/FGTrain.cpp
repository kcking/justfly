// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGTrain.h"
#include "Components/SceneComponent.h"

float TrainConstants::CATCH_DISTANCE = float();
float TrainConstants::STOP_OFFSET = float();
float TrainConstants::DOCK_DISTANCE = float();
float TrainConstants::DOCK_SPEED = float();
float TrainConstants::RESTRICTED_SPEED = float();
bool FTrainAtcData::SetPath(const FRailroadPathFindingResult& result){ return bool(); }
void FTrainAtcData::ClearPath(){ }
bool FTrainAtcData::HasPath() const{ return bool(); }
void FTrainAtcData::UpdateTargetPoints(UFGRailroadTrackConnectionComponent* current){ }
bool FTrainAtcData::UpdateCurrentPathSegment(UFGRailroadTrackConnectionComponent* current){ return bool(); }
bool FTrainAtcData::IsRelevantForATC(const UFGRailroadTrackConnectionComponent* connection){ return bool(); }
AFGTrain::AFGTrain() : Super() {
	this->PrimaryActorTick.TickGroup = TG_PrePhysics; this->PrimaryActorTick.EndTickGroup = TG_PrePhysics; this->PrimaryActorTick.bTickEvenWhenPaused = false; this->PrimaryActorTick.bCanEverTick = true; this->PrimaryActorTick.bStartWithTickEnabled = true; this->PrimaryActorTick.bAllowTickOnDedicatedServer = true; this->PrimaryActorTick.TickInterval = 0.200000002980232;
	this->bAlwaysRelevant = true;
	this->bReplicates = true;
	this->RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));
}
void AFGTrain::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const{ }
void AFGTrain::Tick(float DeltaSeconds){ }
void AFGTrain::BeginPlay(){ }
void AFGTrain::Destroyed(){ }
void AFGTrain::EndPlay(const EEndPlayReason::Type EndPlayReason){ }
bool AFGTrain::IsLevelBoundsRelevant() const{ return bool(); }
void AFGTrain::PreSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGTrain::PostSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGTrain::PreLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGTrain::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGTrain::GatherDependencies_Implementation(TArray< UObject* >& out_dependentObjects){ }
bool AFGTrain::NeedTransform_Implementation(){ return bool(); }
bool AFGTrain::ShouldSave_Implementation() const{ return bool(); }
void AFGTrain::TickAtc(float dt){ }
void AFGTrain::TickSelfDriving(float dt){ }
void AFGTrain::GainedSignificance_Implementation(){ }
void AFGTrain::LostSignificance_Implementation(){ }
void AFGTrain::GainedSignificance_Native(){ }
void AFGTrain::LostSignificance_Native(){ }
float AFGTrain::GetSignificanceRange(){ return float(); }
void AFGTrain::SetTrainName(const FText& name){ }
bool AFGTrain::IsPlayerDriven() const{ return bool(); }
bool AFGTrain::IsSelfDrivingEnabled() const{ return bool(); }
void AFGTrain::SetSelfDrivingEnabled(bool isEnabled){ }
AFGLocomotive* AFGTrain::GetMultipleUnitMaster() const{ return nullptr; }
bool AFGTrain::CanSetMultipleUnitMaster(const  AFGLocomotive* locomotive) const{ return bool(); }
bool AFGTrain::SetMultipleUnitMaster( AFGLocomotive* locomotive, bool force){ return bool(); }
bool AFGTrain::IsInputDisabled() const{ return bool(); }
AFGRailroadTimeTable* AFGTrain::GetTimeTable() const{ return nullptr; }
AFGRailroadTimeTable* AFGTrain::NewTimeTable(){ return nullptr; }
bool AFGTrain::HasTimeTable() const{ return bool(); }
AFGRailroadVehicle* AFGTrain::GetFirstVehicle() const{ return nullptr; }
AFGRailroadVehicle* AFGTrain::GetLastVehicle() const{ return nullptr; }
void AFGTrain::Dock(){ }
void AFGTrain::OnDocked(AFGBuildableRailroadStation* station){ }
void AFGTrain::OnDockingComplete(){ }
void AFGTrain::OnConsistChanged(){ }
void AFGTrain::ReportSelfDrivingError(ESelfDrivingLocomotiveError error){ }
void AFGTrain::ClearSelfDrivingError(){ }
bool AFGTrain::FindPath( AFGBuildableRailroadStation* station){ return bool(); }
void AFGTrain::SetDockingState(ETrainDockingState state){ }
void AFGTrain::GotoSelfDrivingState(ESelfDrivingLocomotiveState newState){ }
void AFGTrain::TickSelfDriving_Idle(){ }
void AFGTrain::TickSelfDriving_FollowPath(){ }
void AFGTrain::TickSelfDriving_Docking(){ }
void AFGTrain::TickSelfDriving_DockingCompleted(){ }
float AFGTrain::CalcBrakeDistance(float currentSpeed, float targetSpeed, float deceleration) const{ return float(); }
float AFGTrain::CalcTargetSpeed(float targetSpeed, float distance, float deceleration) const{ return float(); }
float AFGTrain::CalcTargetAcceleration(float currentSpeed, float targetSpeed, float distance) const{ return float(); }
float AFGTrain::CalcTargetDeceleration(float currentSpeed, float targetSpeed, float distance) const{ return float(); }
void AFGTrain::OnRep_DockingState(){ }
void AFGTrain::OnRep_IsSelfDrivingEnabled(){ }
